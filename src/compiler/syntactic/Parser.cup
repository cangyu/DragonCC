package compiler.syntactic;

import java.io.*;
//import compiler.ast.*;

parser code
{:
public void report_error(String msg, Object info)
{
	StringBuffer m = new StringBuffer("\tParsing Error!");
	if(info instanceof java_cup.runtime.Symbol)
	{
		java_cup.runtime.Symbol s= (java_cup.runtime.Symbol)info;
		if(s.left>=0)
		{
			m.append(" in line " + (s.left +1 ));
			if (s.right >= 0)
			{
				m.append(", column " + (s.right + 1));
				if(s.value!=null)
					m.append(": "+s.value);
			}
		}
	}
	m.append(" : " + msg);
	System.err.println(m);
	System.exit(1);
}

public Parser(InputStream in)
{
	this(new Lexer(new InputStreamReader(in))); 
}

public Parser(Reader in)
{
	this(new Lexer(in));
}
:}

/* Terminal */
terminal VOID, CHAR, INT, STRUCT, UNION, IF, ELSE, WHILE, FOR, CONTINUE, BREAK, RETURN, SIZEOF;
terminal LPAREN, RPAREN, LBRACE, RBRACE, LMPAREN, RMPAREN;
terminal SEMI, COMMA, PLUS, MINUS, TIMES, DIVIDE, MODULE;
terminal INC, DEC;
terminal MUL_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, ADD_ASSIGN, SUB_ASSIGN, SHL_ASSIGN, SHR_ASSIGN, AND_ASSIGN, XOR_ASSIGN, OR_ASSIGN;
terminal NOT, OR, AND, DOT, PTR;
terminal EQ, NE, LT, LE, GT, GE, ASSIGN;
terminal BIT_OR, BIT_XOR, BIT_AND, BIT_NOT, SHL, SHR;
terminal String	ID;
terminal Integer NUM;
terminal String	STRINGCONTENT;
terminal Character CHARCONTENT;

/* Non Terminal */
non terminal program;
non terminal decl_or_func_def;

non terminal stars;
non terminal plain_declarator;
non terminal declarator;
non terminal init_declarator;

non terminal plain_decl;
non terminal decl;
non terminal non_init_decl;

non terminal declarators;
non terminal init_declarators;
non terminal decls;
non terminal non_init_decls;

non terminal initializer;
non terminal initializers;

non terminal type_specifier;
non terminal parameters;
non terminal func_def;

/* Statements */
non terminal stmt;
non terminal stmts;

non terminal expression_stmt;
non terminal compound_stmt;
non terminal selection_stmt;
non terminal jump_stmt;
non terminal iteration_stmt;

/* Expressions */
non terminal expression;
non terminal assignment_expression;
non terminal logical_and_expression;
non terminal logical_or_expression;
non terminal inclusive_or_expression;
non terminal exclusive_or_expression;
non terminal and_expression;
non terminal equality_expression;
non terminal relational_expression;
non terminal shift_expression;
non terminal additive_expression;
non terminal multiplicative_expression;
non terminal cast_expression;
non terminal unary_expression;
non terminal postfix_expression;
non terminal primary_expression;
non terminal constant_expression;

non terminal type_name;
non terminal arguments;

precedence nonassoc ELSE;
 
start with program;

//the expressions in priority hierarchy
primary_expression ::= ID:id
					 | STRINGCONTENT:str
					 | LPAREN expression:e RPAREN
					 | NUM:num
					 | CHARCONTENT:ch;

postfix_expression ::= primary_expression:pe
					 | postfix_expression:pe LMPAREN expression:index RMPAREN
					 | postfix_expression:pe LPAREN RPAREN
					 | postfix_expression:pe LPAREN arguments:arg RPAREN
					 | postfix_expression:pe DOT ID:id
					 | postfix_expression:pe PTR ID:id
					 | postfix_expression:pe INC
					 | postfix_expression:pe DEC;

unary_expression ::= postfix_expression:pe
                   | INC unary_expression:ue
                   | DEC unary_expression:ue
                   | BIT_AND cast_expression:ce
                   | TIMES cast_expression:ce
                   | PLUS cast_expression:ce
                   | MINUS cast_expression:ce
                   | BIT_NOT cast_expression:ce
                   | NOT cast_expression:ce
                   | SIZEOF unary_expression:ue
                   | SIZEOF LPAREN type_name:t RPAREN;

cast_expression	::= unary_expression:ue
				  | LPAREN type_name:t RPAREN cast_expression:ce;

multiplicative_expression ::= cast_expression:ce
							| multiplicative_expression:me TIMES cast_expression:ce
						    | multiplicative_expression:me DIVIDE cast_expression:ce
						    | multiplicative_expression:me MODULE cast_expression:ce;

additive_expression	::= multiplicative_expression:me
                      | additive_expression:ae PLUS multiplicative_expression:me
                      | additive_expression:ae MINUS multiplicative_expression:me;
                      
shift_expression ::= additive_expression:ae
				   | shift_expression:se SHL additive_expression:ae
				   | shift_expression:se SHR additive_expression:ae;                      
                                      
					
relational_expression ::= shift_expression:se
					    | relational_expression:re LT shift_expression:se
	                    | relational_expression:re GT shift_expression:se
	                    | relational_expression:re LE shift_expression:se
	                    | relational_expression:re GE shift_expression:se;                  
                      
equality_expression	::= relational_expression:re
					  | equality_expression:ee EQ relational_expression:re
					  | equality_expression:ee NE relational_expression:re;	                      
                      
and_expression ::= equality_expression:ee
				 | and_expression:ae BIT_AND equality_expression:ee;
				 
exclusive_or_expression	::= and_expression:ae
						  | exclusive_or_expression:eoe BIT_XOR and_expression:ae;
						  
inclusive_or_expression	::= exclusive_or_expression:eoe
						  | inclusive_or_expression:ioe BIT_OR exclusive_or_expression:eoe;
						  
logical_and_expression ::= inclusive_or_expression:ioe
						 | logical_and_expression:lae AND inclusive_or_expression:ioe;               
                      
logical_or_expression ::= logical_and_expression:lae
						| logical_or_expression:loe OR logical_and_expression:lae;
						
assignment_expression ::= logical_or_expression:loe
                        | unary_expression:ue ASSIGN assignment_expression:ae
                        | unary_expression:ue MUL_ASSIGN assignment_expression:ae
                        | unary_expression:ue DIV_ASSIGN assignment_expression:ae
                        | unary_expression:ue MOD_ASSIGN assignment_expression:ae
                        | unary_expression:ue ADD_ASSIGN assignment_expression:ae
                        | unary_expression:ue SUB_ASSIGN assignment_expression:ae
                        | unary_expression:ue SHL_ASSIGN assignment_expression:ae
                        | unary_expression:ue SHR_ASSIGN assignment_expression:ae
                        | unary_expression:ue AND_ASSIGN assignment_expression:ae
                        | unary_expression:ue XOR_ASSIGN assignment_expression:ae
                        | unary_expression:ue OR_ASSIGN assignment_expression:ae;
				  
constant_expression ::= logical_or_expression:loe;

expression ::= assignment_expression:ae
			 | expression COMMA assignment_expression:ae;

//the declarators, from simple to complex and multiple
stars ::= TIMES
        | stars:ss TIMES;

plain_declarator ::= ID:id
                   | stars:ss ID:id;

declarator ::= plain_declarator:pd
             | declarator:d LMPAREN constant_expression:ce RMPAREN;

declarators ::= declarator:d
              | declarators:ds COMMA declarator:d;
              
init_declarator ::= declarator:d
                  | declarator:d ASSIGN initializer:i;              
              						
init_declarators ::= init_declarator:id
                   | init_declarators:ids COMMA init_declarator:id;

//the declarations, from simple to complex and multiple
plain_decl ::= type_specifier:t declarator:d;

decl ::= type_specifier:t init_declarators:id SEMI
       | type_specifier:t SEMI;
       
decls ::= decl:d
        | decls:ds decl:d;       
       
non_init_decl ::= type_specifier:t declarators:ds SEMI;

non_init_decls ::= non_init_decl:nid
                 | non_init_decls:nids non_init_decl:nid;
                 
//initializer, mutual inclusive
initializer ::= assignment_expression:ae
              | LBRACE initializers:is RBRACE;

initializers ::= initializer:i
               | initializers:is COMMA initializer:i;
       
//types
type_specifier ::= VOID
                 | CHAR
                 | INT
                 | STRUCT ID:id LBRACE non_init_decls:nids RBRACE
                 | STRUCT LBRACE non_init_decls:nids RBRACE
                 | STRUCT ID:id
                 | UNION ID:id LBRACE non_init_decls:nids RBRACE
                 | UNION LBRACE non_init_decls:nids RBRACE
                 | UNION ID:id;
                 
type_name ::= type_specifier:ts
            | type_specifier:ts stars:ss;
                 
//function
parameters ::= plain_decl:pd
             | parameters:p COMMA plain_decl:pd;

arguments ::= assignment_expression:ae  
            | arguments:args COMMA assignment_expression:ae;

func_def ::= type_specifier:t plain_declarator:pd LPAREN RPAREN compound_stmt:cs
           | type_specifier:t plain_declarator:pd LPAREN parameters:p RPAREN compound_stmt:cs;

//program
program ::= program:p decl_or_func_def:df
		  | decl_or_func_def:df;

decl_or_func_def ::= decl:d
				   | func_def:fd;

//statements
stmt ::= expression_stmt:es
	   | compound_stmt:cs
	   | selection_stmt:ss
	   | iteration_stmt:is
	   | jump_stmt:js;
	   
stmts ::= stmt:s
	    | stmts:ss stmt:s;
	 
expression_stmt ::= SEMI
                  | expression:e SEMI;

compound_stmt ::= LBRACE RBRACE
                | LBRACE stmts:ss RBRACE
                | LBRACE decls:ds RBRACE
                | LBRACE decls:ds stmts:ss RBRACE;
		 
selection_stmt ::= IF LPAREN expression:cond RPAREN stmt:st1 ELSE stmt:st2
			     | IF LPAREN expression:cond RPAREN stmt:st;

jump_stmt ::= CONTINUE SEMI
		    | BREAK SEMI
		    | RETURN SEMI
		    | RETURN expression:e SEMI;
		    
iteration_stmt ::= WHILE LPAREN expression:cond RPAREN stmt:st
			     | FOR LPAREN  SEMI  SEMI  RPAREN stmt:st
			     | FOR LPAREN  SEMI  SEMI expression:e3 RPAREN stmt:st
			     | FOR LPAREN  SEMI expression:e2 SEMI  RPAREN stmt:st
			     | FOR LPAREN  SEMI expression:e2 SEMI expression:e3 RPAREN stmt:st
			     | FOR LPAREN expression:e1 SEMI  SEMI  RPAREN stmt:st
			     | FOR LPAREN expression:e1 SEMI  SEMI expression:e3 RPAREN stmt:st
			     | FOR LPAREN expression:e1 SEMI expression:e2 SEMI  RPAREN stmt:st
			     | FOR LPAREN expression:e1 SEMI expression:e2 SEMI expression:e3 RPAREN stmt:st;	 
			